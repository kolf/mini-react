# React 18 源码架构梳理

## 📋 项目概览

我们正在手写实现React 18的核心功能，目前已经完成了基础架构的搭建。项目采用模块化设计，分为三个主要包：

```
src/my-react/
├── react/              # React核心包 - 提供createElement、Component等API
├── react-dom/          # ReactDOM包 - 提供渲染相关API
└── react-reconciler/   # 协调器包 - 实现Fiber架构和调度逻辑
```

## 🏗️ 架构设计思想

### 1. 分层架构
- **React层**: 提供开发者API，如createElement、Component
- **ReactDOM层**: 处理DOM相关操作，如createRoot、render
- **Reconciler层**: 核心调度和协调逻辑，实现Fiber架构

### 2. Fiber架构核心概念
- **Fiber节点**: React元素的内部表示，包含完整的渲染信息
- **双缓冲技术**: current树和workInProgress树交替工作
- **可中断渲染**: 支持时间切片和优先级调度

## 📁 详细代码分析

### React核心包 (`/react/`)

#### 1. ReactTypes.ts - 类型定义系统
```typescript
// 核心类型定义
ReactElement    // React元素的类型定义
ReactNode      // 可渲染内容的联合类型
ReactText      // 文本内容类型
Key           // 用于diff算法的唯一标识
Ref           // DOM引用或组件实例引用
```

**关键理解点**:
- `ReactElement`是React应用的基本构建块
- `ReactNode`定义了所有可以被React渲染的内容类型
- `Key`和`Ref`是React中的特殊属性，不会传递给组件

#### 2. ReactElement.ts - 元素创建核心
```typescript
// 主要功能
createElement()     // JSX转换的目标函数
isValidElement()   // 验证React元素的有效性
cloneElement()     // 克隆React元素
```

**工作流程**:
1. JSX语法 → Babel转换 → createElement调用
2. 提取key、ref等特殊属性
3. 处理children和defaultProps
4. 返回标准化的ReactElement对象

**核心数据结构**:
```typescript
ReactElement = {
  $$typeof: Symbol.for('react.element'),  // 类型标识
  type: 'div' | Component,                // 元素类型
  key: string | null,                     // diff优化标识
  ref: Ref | null,                        // DOM引用
  props: { children, ...otherProps }      // 属性对象
}
```

#### 3. ReactBaseClasses.ts - 组件基类
```typescript
// 主要类
Component      // 基础组件类
PureComponent  // 优化版组件类（自动浅比较）
```

**Component类核心功能**:
- `setState()`: 状态更新机制
- `forceUpdate()`: 强制重新渲染
- `render()`: 渲染方法（抽象方法）

**PureComponent优化原理**:
- 自动实现`shouldComponentUpdate`
- 使用浅比较算法比较props和state
- 避免不必要的重新渲染

### ReactDOM包 (`/react-dom/`)

#### 1. ReactDOMRoot.ts - React 18新根API
```typescript
// 核心API
createRoot()   // 创建React 18根容器
Root.render()  // 渲染React元素
Root.unmount() // 卸载应用
```

**React 18新特性支持**:
- 并发渲染能力
- 自动批处理
- Suspense边界支持
- 更好的开发体验

#### 2. ReactDOMLegacy.ts - 兼容性API
```typescript
// 兼容API
render()                    // React 17风格的渲染API
unmountComponentAtNode()    // 卸载组件
```

### Reconciler包 (`/react-reconciler/`)

#### 1. ReactFiber.ts - Fiber节点核心
```typescript
// 核心数据结构
interface Fiber {
  // 节点标识
  tag: WorkTag              // 节点类型
  key: Key                  // diff标识
  type: any                 // 元素类型
  
  // 树形结构
  return: Fiber             // 父节点
  child: Fiber              // 第一个子节点
  sibling: Fiber            // 下一个兄弟节点
  
  // 状态信息
  pendingProps: any         // 新的props
  memoizedProps: any        // 旧的props
  memoizedState: any        // 旧的state
  updateQueue: any          // 更新队列
  
  // 副作用标记
  flags: Flags              // 当前节点的副作用
  subtreeFlags: Flags       // 子树的副作用
  
  // 双缓冲
  alternate: Fiber          // 对应的另一棵树的节点
}
```

**WorkTag类型**:
- `FunctionComponent`: 函数组件
- `ClassComponent`: 类组件
- `HostRoot`: 根节点
- `HostComponent`: DOM元素
- `HostText`: 文本节点

**Flags副作用标记**:
- `Placement`: 需要插入DOM
- `Update`: 需要更新属性
- `Deletion`: 需要删除

#### 2. ReactFiberRoot.ts - 根节点管理
```typescript
interface FiberRoot {
  containerInfo: Element        // DOM容器
  current: Fiber               // 当前Fiber树根
  finishedWork: Fiber          // 完成的工作树
  // 调度相关字段...
}
```

#### 3. ReactUpdateQueue.ts - 更新队列
```typescript
// 更新对象
interface Update {
  payload: any              // 更新内容
  callback: Function        // 回调函数
  next: Update             // 下一个更新（环形链表）
}

// 更新队列
interface UpdateQueue {
  baseState: any           // 基础状态
  shared: {
    pending: Update        // 待处理更新
  }
}
```

**更新流程**:
1. 创建Update对象
2. 加入环形链表
3. 调度更新
4. 处理更新队列

#### 4. ReactFiberReconciler.ts - 协调器入口
```typescript
// 主要功能
createContainer()    // 创建Fiber根容器
updateContainer()    // 更新容器内容
```

## 🔄 数据流向分析

### 1. 应用启动流程
```
createRoot(container) 
  → createContainer() 
  → createFiberRoot() 
  → 返回Root对象
```

### 2. 渲染流程
```
root.render(element)
  → updateContainer()
  → 创建Update对象
  → enqueueUpdate()
  → scheduleUpdateOnFiber()
  → 开始工作循环
```

### 3. Fiber树构建
```
current树 ←→ workInProgress树
     ↓
  双缓冲切换
     ↓
  提交到DOM
```

## 🎯 核心设计模式

### 1. 工厂模式
- `createElement`: 创建ReactElement
- `createFiber`: 创建Fiber节点
- `createUpdate`: 创建更新对象

### 2. 链表结构
- Fiber树: 使用child/sibling/return构建树形结构
- 更新队列: 使用环形链表管理更新

### 3. 双缓冲模式
- current树: 当前显示的UI
- workInProgress树: 正在构建的新UI
- 完成后交换两棵树

### 4. 位运算优化
- Flags: 使用位运算标记副作用
- 高效的标记合并和检查

## 🚀 下一步实现计划

### 已完成 ✅
- [x] 基础类型定义
- [x] ReactElement创建
- [x] 组件基类
- [x] Fiber数据结构
- [x] 更新队列
- [x] 根容器创建

### 待实现 🔄
- [ ] 工作循环 (ReactFiberWorkLoop)
- [ ] 协调算法 (beginWork/completeWork)
- [ ] 提交阶段 (commitWork)
- [ ] Hooks系统
- [ ] 事件系统
- [ ] 调度器

## 💡 学习要点

### 1. 理解Fiber架构的优势
- **可中断**: 长任务可以被分割
- **优先级**: 不同更新有不同优先级
- **并发**: 支持并发特性

### 2. 掌握React的核心概念
- **ReactElement**: 描述UI的数据结构
- **Fiber**: 内部工作单元
- **更新队列**: 状态变更的管理
- **双缓冲**: 平滑的UI更新

### 3. 深入理解渲染流程
- **调度阶段**: 决定何时更新
- **协调阶段**: 计算变更（可中断）
- **提交阶段**: 应用变更到DOM（同步）

这个架构为我们后续实现React的高级特性（如Hooks、Suspense、并发渲染等）奠定了坚实的基础。