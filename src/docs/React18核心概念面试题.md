# React 18 核心概念面试题（50题）

## 📚 基础概念篇

### 1. React 18相比React 17有哪些主要改进？
**答案：**
- **并发渲染**：支持可中断的渲染过程，提高应用响应性
- **自动批处理**：自动合并多个状态更新，减少不必要的渲染
- **新的根API**：`createRoot`替代`ReactDOM.render`，支持并发特性
- **Suspense改进**：更好的异步组件和错误边界支持
- **严格模式增强**：开发模式下更好的调试体验

### 2. 什么是Fiber架构？它解决了什么问题？
**答案：**
Fiber是React 16引入的新协调引擎，解决了：
- **同步渲染阻塞**：React 15的递归渲染会阻塞主线程
- **优先级调度**：支持高优先级任务中断低优先级任务
- **增量渲染**：将渲染工作分解为多个小任务
- **错误恢复**：单个组件错误不会导致整个应用崩溃
- **并发渲染**：支持可中断的渲染过程，提高应用响应性
- **自动批处理**：自动合并多个状态更新，减少不必要的渲染

### 3. ReactElement和Fiber节点有什么区别？
**答案：**
- **ReactElement**：描述UI的不可变对象，包含type、props、key等信息
- **Fiber节点**：React内部的工作单元，包含状态、副作用、链表指针等
- **关系**：每个ReactElement对应一个或多个Fiber节点

### 4. 解释React的协调算法（Reconciliation）
**答案：**
协调算法是React比较新旧虚拟DOM树的diff算法：
- **树比较策略**：只比较同一层级的节点
- **Key的重要性**：使用key标识节点身份，提高diff效率
- **节点类型比较**：类型不同直接替换整个子树
- **列表diff优化**：通过key减少不必要的DOM操作

### 5. 什么是虚拟DOM？它的优势是什么？
**答案：**
虚拟DOM是内存中的DOM表示：
- **优势**：
  - 跨平台渲染（React Native）
  - 性能优化（批量DOM操作）
  - 开发体验（声明式编程）
  - 测试友好（不依赖真实DOM）

## 🔧 组件系统篇

### 6. 类组件和函数组件的主要区别？
**答案：**
- **生命周期**：类组件有完整的生命周期方法，函数组件使用Hooks
- **状态管理**：类组件使用this.state，函数组件使用useState
- **性能优化**：类组件有shouldComponentUpdate，函数组件使用React.memo
- **代码组织**：函数组件更简洁，逻辑更集中

### 7. PureComponent和普通Component的区别？
**答案：**
- **浅比较**：PureComponent自动实现props和state的浅比较
- **性能优化**：避免不必要的重新渲染
- **使用场景**：适用于props和state都是简单数据类型的组件

### 8. 什么是高阶组件（HOC）？它的使用场景？
**答案：**
高阶组件是接收组件返回新组件的函数：
```jsx
const withAuth = (Component) => (props) => {
  return isAuthenticated ? <Component {...props} /> : <Login />;
};
```
**使用场景**：代码复用、权限控制、日志记录等

### 9. 解释React的合成事件系统
**答案：**
- **事件委托**：所有事件委托到document级别
- **跨浏览器兼容**：统一不同浏览器的事件对象
- **性能优化**：减少内存占用，自动清理事件监听器
- **事件池**：重用事件对象，减少垃圾回收

### 10. 什么是受控组件和非受控组件？
**答案：**
- **受控组件**：表单值由React状态管理
- **非受控组件**：表单值由DOM自身管理（使用ref）
- **选择依据**：根据表单复杂度和验证需求选择

## 🎣 Hooks系统篇

### 11. useState Hook的工作原理？
**答案：**
- **链表结构**：Hooks按调用顺序存储在链表中
- **状态隔离**：每个组件实例有独立的Hook状态
- **更新机制**：调用setState触发重新渲染
- **批量更新**：React 18自动批处理多个状态更新

### 12. useEffect和useLayoutEffect的区别？
**答案：**
- **执行时机**：
  - useEffect：在浏览器绘制后异步执行
  - useLayoutEffect：在DOM更新后同步执行
- **使用场景**：
  - useEffect：数据获取、订阅等副作用
  - useLayoutEffect：DOM测量、动画等需要同步的操作

### 13. useCallback和useMemo的优化原理？
**答案：**
- **useCallback**：缓存函数引用，避免子组件不必要重渲染
- **useMemo**：缓存计算结果，避免重复计算
- **依赖数组**：只有当依赖项变化时才重新计算

### 14. 自定义Hook的设计原则？
**答案：**
- **单一职责**：每个Hook只解决一个特定问题
- **命名规范**：以use开头，描述功能
- **依赖明确**：清晰定义输入输出和依赖关系
- **可测试性**：易于单元测试和复用

### 15. useContext的使用场景和注意事项？
**答案：**
**使用场景**：主题切换、用户认证、多语言等全局状态
**注意事项**：
- 避免过度使用，导致组件依赖不明确
- 配合useReducer管理复杂状态
- 考虑性能影响，使用memo优化子组件

## ⚡ 并发特性篇

### 16. React 18的并发特性是什么？
**答案：**
- **时间切片**：将渲染工作分解为可中断的小任务
- **优先级调度**：用户交互等高优先级任务优先执行
- **Suspense for Data Fetching**：更好的异步数据处理
- **Transition API**：区分紧急和非紧急更新

### 17. 什么是自动批处理？它如何工作？
**答案：**
自动批处理是React 18将多个状态更新合并为一次渲染：
```jsx
// React 17：两次渲染
setCount(1);
setName('John');

// React 18：一次渲染（自动批处理）
setCount(1);
setName('John');
```

### 18. startTransition API的作用？
**答案：**
用于标记非紧急的状态更新：
```jsx
import { startTransition } from 'react';

startTransition(() => {
  setSearchQuery(query); // 非紧急更新
});
```
**效果**：紧急更新（如用户输入）优先执行

### 19. useDeferredValue Hook的使用场景？
**答案：**
延迟某个值的更新，保持UI响应性：
```jsx
const deferredQuery = useDeferredValue(query);
```
**使用场景**：搜索框、大型列表渲染等

### 20. Suspense组件的工作原理？
**答案：**
- **异步边界**：包装异步组件，显示加载状态
- **错误处理**：配合Error Boundary处理加载错误
- **数据获取**：支持Suspense for Data Fetching

## 🏗️ 渲染流程篇

### 21. React的渲染流程分为哪几个阶段？
**答案：**
1. **调度阶段**：确定更新的优先级和时机
2. **协调阶段**：比较新旧虚拟DOM，生成副作用列表
3. **提交阶段**：将变更应用到真实DOM

### 22. Fiber架构的双缓冲机制？
**答案：**
- **Current树**：当前显示在屏幕上的Fiber树
- **WorkInProgress树**：正在构建的新Fiber树
- **切换机制**：构建完成后交换两棵树，实现无闪烁更新

### 23. React的优先级调度算法？
**答案：**
- **即时优先级**：用户输入、动画等
- **普通优先级**：数据更新、UI渲染
- **低优先级**：预加载、后台任务
- **空闲优先级**：不紧急的任务

### 24. 什么是时间切片（Time Slicing）？
**答案：**
将渲染工作分解为5ms的小任务：
- **可中断**：高优先级任务可以中断当前渲染
- **恢复机制**：从中断点继续渲染工作
- **性能优化**：避免长时间任务阻塞主线程

### 25. React的错误边界机制？
**答案：**
- **组件捕获**：class组件的componentDidCatch方法
- **错误处理**：显示降级UI，避免整个应用崩溃
- **使用限制**：不能捕获事件处理器、异步代码等错误

## 🔄 状态管理篇

### 26. React的状态更新是同步还是异步？
**答案：**
- **React 17**：事件处理器中是批处理的，setTimeout中是同步的
- **React 18**：所有场景都是批处理的（自动批处理）

### 27. setState的更新合并机制？
**答案：**
```jsx
// 对象式更新：合并到当前state
this.setState({ count: 1 });
this.setState({ name: 'John' });
// 结果：{ count: 1, name: 'John' }

// 函数式更新：基于前一个状态
this.setState(prevState => ({ count: prevState.count + 1 }));
```

### 28. 使用useState时如何避免过时闭包？
**答案：**
- **函数式更新**：使用函数形式的setState
- **useReducer**：复杂状态逻辑使用useReducer
- **useRef**：存储可变值，不触发重新渲染

### 29. Context API的性能优化策略？
**答案：**
- **拆分Context**：按功能拆分多个小Context
- **memo优化**：使用React.memo避免不必要重渲染
- **选择器模式**：使用useContextSelector等库

### 30. useReducer vs useState的选择依据？
**答案：**
- **useState**：简单状态、独立的状态更新
- **useReducer**：复杂状态逻辑、多个相关联的状态更新

## 🎯 性能优化篇

### 31. React.memo的工作原理？
**答案：**
- **浅比较**：比较props是否发生变化
- **自定义比较**：可以传入第二个参数进行深度比较
- **使用场景**：避免子组件不必要重渲染

### 32. 如何优化大型列表的渲染性能？
**答案：**
- **虚拟化**：使用react-window等库实现虚拟滚动
- **分页加载**：分批加载数据
- **key优化**：使用稳定唯一的key
- **memo优化**：列表项使用React.memo

### 33. useMemo和useCallback的合理使用？
**答案：**
**应该使用**：
- 计算昂贵的值
- 防止子组件不必要重渲染
- 依赖项变化时才重新计算

**避免过度使用**：
- 简单计算不需要useMemo
- 组件内部函数通常不需要useCallback

### 34. 代码分割的最佳实践？
**答案：**
- **路由级分割**：使用React.lazy按路由分割
- **组件级分割**：大型组件使用动态导入
- **预加载策略**：使用Suspense和预加载提示

### 35. 如何诊断React性能问题？
**答案：**
- **React DevTools**：Profiler工具分析组件渲染
- **Chrome Performance**：录制性能分析
- **控制台警告**：关注key警告和渲染次数警告

## 🔗 高级特性篇

### 36. Portal的使用场景和实现原理？
**答案：**
**使用场景**：模态框、工具提示、下拉菜单等需要脱离当前DOM结构的组件
**实现原理**：使用ReactDOM.createPortal将组件渲染到指定DOM节点

### 37. Ref的三种使用方式？
**答案：**
1. **字符串Ref**（已废弃）：`ref="myRef"`
2. **回调Ref**：`ref={(node) => this.myRef = node}`
3. **createRef**：`this.myRef = React.createRef()`
4. **useRef Hook**：`const myRef = useRef()`

### 38. forwardRef的作用和使用场景？
**答案：**
**作用**：将ref传递给子组件
**使用场景**：高阶组件、封装第三方组件等需要访问DOM节点的场景

### 39. useImperativeHandle Hook的使用？
**答案：**
自定义暴露给父组件的实例值：
```jsx
useImperativeHandle(ref, () => ({
  focus: () => inputRef.current.focus(),
  clear: () => inputRef.current.value = ''
}));
```

### 40. 错误边界的最佳实践？
**答案：**
- **粒度控制**：在关键组件周围添加错误边界
- **用户体验**：提供有意义的错误信息和恢复选项
- **日志记录**：将错误信息发送到错误监控系统

## 🛠️ 开发实践篇

### 41. React项目的目录结构设计？
**答案：**
```
src/
├── components/ # 可复用组件
├── pages/ # 页面组件
├── hooks/ # 自定义Hooks
├── utils/ # 工具函数
├── services/ # API服务
├── store/ # 状态管理
└── types/ # TypeScript类型定义
```

### 42. TypeScript在React中的最佳实践？
**答案：**
- **组件Props**：使用interface或type定义
- **事件处理**：使用React的事件类型
- **泛型组件**：创建可复用的泛型组件
- **严格模式**：启用strict模式确保类型安全

### 43. React测试的最佳实践？
**答案：**
- **单元测试**：使用Jest测试工具函数和纯函数
- **组件测试**：使用React Testing Library测试组件行为
- **集成测试**：测试多个组件的交互
- **快照测试**：确保UI不意外更改

### 44. React项目的代码规范？
**答案：**
- **命名规范**：组件使用PascalCase，其他使用camelCase
- **文件组织**：一个文件一个组件，相关文件放在一起
- **导入顺序**：第三方库 → 内部模块 → 相对路径
- **代码分割**：合理使用动态导入和代码分割

### 45. React项目的构建优化？
**答案：**
- **打包优化**：使用代码分割和tree shaking
- **缓存策略**：配置合理的缓存策略
- **压缩优化**：代码压缩和资源优化
- **预加载**：关键资源预加载

## 🔮 未来趋势篇

### 46. React Server Components的特点？
**答案：**
- **服务端渲染**：在服务端执行，减少客户端包大小
- **零包大小**：服务端组件不包含在客户端bundle中
- **数据获取**：直接在服务端获取数据
- **渐进采用**：可以与客户端组件混合使用

### 47. React Compiler的作用？
**答案：**
- **自动优化**：自动应用useMemo和useCallback等优化
- **开发体验**：减少手动优化的工作量
- **性能提升**：通过静态分析提供更好的性能

### 48. 微前端在React中的应用？
**答案：**
- **模块联邦**：使用Webpack 5的Module Federation
- **单SPA**：使用single-spa等框架
- **iframe方案**：简单的隔离方案
- **Web Components**：使用自定义元素集成

### 49. React在移动端的发展？
**答案：**
- **React Native**：使用React开发原生移动应用
- **PWA支持**：渐进式Web应用
- **跨端框架**：Taro、uni-app等多端开发框架

### 50. React的未来发展方向？
**答案：**
- **并发特性**：进一步完善并发渲染能力
- **服务端组件**：推广Server Components的使用
- **编译器优化**：React Compiler的广泛应用
- **开发体验**：更好的调试工具和开发体验

## 📖 学习建议

这些面试题涵盖了React 18的核心概念，建议结合实际项目经验进行深入理解。每个问题都对应着React架构中的重要设计决策，理解这些概念有助于写出更高质量的React代码。

**学习路径建议**：
1. 先掌握基础概念（1-25题）
2. 深入理解Hooks和状态管理（26-40题）
3. 学习性能优化和高级特性（31-45题）
4. 了解未来发展趋势（46-50题）

**实践建议**：
- 结合源码学习，理解实现原理
- 在实际项目中应用所学知识
- 关注React官方博客和更新日志
- 参与开源项目，积累实战经验